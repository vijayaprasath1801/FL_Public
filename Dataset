
enum Status {
  TERMINATED_WITH_ERROR = "TERMINATED_WITH_ERROR",
  COMPLETED = "COMPLETED",
  PENDING = "PENDING",
}


       <MenuButton
          width={200}
          label="Actions"
          kind="standard"
          selectedValue=""
          role="menu"
          onSelectedValueChange={(value: string) => handleActionValueChange(value, item)}
        >
          {item.paymentsCount === 0 ? (
            <>
              <MenuItem role="menuItem" value="purge">
                Delete/Purge
              </MenuItem>
            </>
          ) : (
            <>
              <MenuItem role="menuItem" value="run">
                Schedule a Run
              </MenuItem>
              <MenuItem role="menuItem" value="purge">
                Purge
              </MenuItem>
            </>
          )}
        </MenuButton>

export const actionOptions = (count) =>{
return count !== 0 ? [
{label:'Schedule a run',
value:'run'},
{label:'Purge', 
value:'purge'}] :
[{label:'Purge', 
value:'purge'}]
}


    formatter: ({ item }: any) => (
        <span
          style={{
            color: item.status === Status.PENDING ? "yellow" : "inherit",
          }}
        >
          {moment(item?.harvestedDate).format("YYYY/MM/DD LT")}
        </span>
      ),


     formatter: ({ item }: any) => (
        <span
          style={{
            color: item.status === Status.PENDING ? "yellow" : "inherit",
          }}
        >
          {item.paymentsCount}
        </span>
      ),


  rowClassName={({ item }: any) =>
    item.status === Status.PENDING ? "highlight-pending-row" : ""
  }

.highlight-pending-row {
  background-color: #fff3cd; /* Light yellow */
  color: #856404; /* Brownish text */
}
  rowClassName={({ item }) =>
    props.highlightRow && item[props.highlightEntries.key] === props.highlightEntries.value
      ? "highlight-pending-row"
      : ""
  }


  if (formSubmitting.current) {
    return; // Prevent duplicate submissions
  }

  formSubmitting.current = true; // Lock form submission

 finally {
    formSubmitting.current = false; // Unlock form submission
  }

    const result = await dispatch(uploadPaymentDatasetAction(formData));
      if (result?.payload?.status === 'success') {
        setOpenPopup(true); // Show popup immediately
      }


 keepUnusedDataFor: 5,
  refetchOnFocus: true, // Re-fetch when the window regains focus
  refetchOnReconnect: true,
 refetchOnMountOrArgChange: true,
 pollingInterval: 5000,


 useEffect(() => {
    // Dispatch initial fetch
    dispatch(fetchAllPaymentDatasetAction());

    // Set up polling for auto-refresh
    const interval = setInterval(() => {
      dispatch(fetchAllPaymentDatasetAction());
    }, 5000); // Adjust the interval as needed, e.g., 5000ms for 5 seconds

    // Clear interval on component unmount
    return () => clearInterval(interval);
  }, [dispatch]);



const [endDateMaxSelectableDate, setEndDateMaxSelectableDate] = useState(null);
const [startDateMinSelectableDate, setStartDateMinSelectableDate] = useState(null);

const handleFormChange = (name, value) => {
  if (name === 'startDate') {
    setFormData({ ...formData, startDate: value });
    // Update the maxSelectableDate for the end date
    setEndDateMaxSelectableDate(new Date(value));
  } else if (name === 'endDate') {
    setFormData({ ...formData, endDate: value });
    // Update the minSelectableDate for the start date
    setStartDateMinSelectableDate(new Date(value));
  }
};

<DatePicker
  required
  label="Start Date"
  name="startDate"
  value={formData.startDate}
  disableWeekends={true}
  onValueChange={handleFormChange}
  maxSelectableDate={endDateMaxSelectableDate}
  customStrings={{
    dateCannotBeAfter: (customDayAfter) => `Date cannot be after ${customDayAfter}`,
  }}
  disabledDates={{
    after: endDateMaxSelectableDate,
  }}
/>

<DatePicker
  required
  label="End Date"
  name="endDate"
  minSelectableDate={startDateMinSelectableDate}
  disableWeekends={true}
  value={formData.endDate}
  fromMonth={formData.startDate}
  customStrings={{
    dateCannotBeBefore: (customDayBefore) => `Date cannot be before ${customDayBefore}`,
  }}
  onValueChange={handleFormChange }
  disabledDates={{
    before: startDateMinSelectableDate,
  }}
/>
