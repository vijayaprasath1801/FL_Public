
enum Status {
  TERMINATED_WITH_ERROR = "TERMINATED_WITH_ERROR",
  COMPLETED = "COMPLETED",
  PENDING = "PENDING",
}


       <MenuButton
          width={200}
          label="Actions"
          kind="standard"
          selectedValue=""
          role="menu"
          onSelectedValueChange={(value: string) => handleActionValueChange(value, item)}
        >
          {item.paymentsCount === 0 ? (
            <>
              <MenuItem role="menuItem" value="purge">
                Delete/Purge
              </MenuItem>
            </>
          ) : (
            <>
              <MenuItem role="menuItem" value="run">
                Schedule a Run
              </MenuItem>
              <MenuItem role="menuItem" value="purge">
                Purge
              </MenuItem>
            </>
          )}
        </MenuButton>

export const actionOptions = (count) =>{
return count !== 0 ? [
{label:'Schedule a run',
value:'run'},
{label:'Purge', 
value:'purge'}] :
[{label:'Purge', 
value:'purge'}]
}


    formatter: ({ item }: any) => (
        <span
          style={{
            color: item.status === Status.PENDING ? "yellow" : "inherit",
          }}
        >
          {moment(item?.harvestedDate).format("YYYY/MM/DD LT")}
        </span>
      ),


     formatter: ({ item }: any) => (
        <span
          style={{
            color: item.status === Status.PENDING ? "yellow" : "inherit",
          }}
        >
          {item.paymentsCount}
        </span>
      ),


  rowClassName={({ item }: any) =>
    item.status === Status.PENDING ? "highlight-pending-row" : ""
  }

.highlight-pending-row {
  background-color: #fff3cd; /* Light yellow */
  color: #856404; /* Brownish text */
}
  rowClassName={({ item }) =>
    props.highlightRow && item[props.highlightEntries.key] === props.highlightEntries.value
      ? "highlight-pending-row"
      : ""
  }


  if (formSubmitting.current) {
    return; // Prevent duplicate submissions
  }

  formSubmitting.current = true; // Lock form submission

 finally {
    formSubmitting.current = false; // Unlock form submission
  }

    const result = await dispatch(uploadPaymentDatasetAction(formData));
      if (result?.payload?.status === 'success') {
        setOpenPopup(true); // Show popup immediately
      }


 keepUnusedDataFor: 5,
  refetchOnFocus: true, // Re-fetch when the window regains focus
  refetchOnReconnect: true,
 refetchOnMountOrArgChange: true,
 pollingInterval: 5000,


 useEffect(() => {
    // Dispatch initial fetch
    dispatch(fetchAllPaymentDatasetAction());

    // Set up polling for auto-refresh
    const interval = setInterval(() => {
      dispatch(fetchAllPaymentDatasetAction());
    }, 5000); // Adjust the interval as needed, e.g., 5000ms for 5 seconds

    // Clear interval on component unmount
    return () => clearInterval(interval);
  }, [dispatch]);



const [endDateMaxSelectableDate, setEndDateMaxSelectableDate] = useState(null);
const [startDateMinSelectableDate, setStartDateMinSelectableDate] = useState(null);

const handleFormChange = (name, value) => {
  if (name === 'startDate') {
    setFormData({ ...formData, startDate: value });
    // Update the maxSelectableDate for the end date
    setEndDateMaxSelectableDate(new Date(value));
  } else if (name === 'endDate') {
    setFormData({ ...formData, endDate: value });
    // Update the minSelectableDate for the start date
    setStartDateMinSelectableDate(new Date(value));
  }
};

<DatePicker
  required
  label="Start Date"
  name="startDate"
  value={formData.startDate}
  disableWeekends={true}
  onValueChange={handleFormChange}
  maxSelectableDate={endDateMaxSelectableDate}
  customStrings={{
    dateCannotBeAfter: (customDayAfter) => `Date cannot be after ${customDayAfter}`,
  }}
  disabledDates={{
    after: endDateMaxSelectableDate,
  }}
/>

<DatePicker
  required
  label="End Date"
  name="endDate"
  minSelectableDate={startDateMinSelectableDate}
  disableWeekends={true}
  value={formData.endDate}
  fromMonth={formData.startDate}
  customStrings={{
    dateCannotBeBefore: (customDayBefore) => `Date cannot be before ${customDayBefore}`,
  }}
  onValueChange={handleFormChange }
  disabledDates={{
    before: startDateMinSelectableDate,
  }}
/>



    customValidators={[
        (value) => {
            const parsedValue = parseInt(value, 10);
            if (isNaN(parsedValue)) {
                return 'Please enter a valid number.';
            }
            if (value.length > 2) {
                return 'Input cannot exceed 2 digits.';
            }
            if (parsedValue < 0 || parsedValue > 23) {
                return 'Allowed Values are: 00-23';
            }
            return null; // No error
        },
    ]}



import { render, screen } from '@testing-library/react';
import PaginatedTable from './PaginatedTable'; // Replace with the correct path

test('renders spinner in paymentsCount column when status is PENDING', () => {
  const pendingMockData = {
    items: [
      {
        datasetName: "test1",
        activeRunId: "123",
        status: "PENDING",
        harvestedDate: "11-02-2024",
        paymentsCount: "5",
      },
    ],
    totalItems: 1,
    pageNumber: 1,
    itemsPerPage: 10,
  };

  const mockColumns = [
    { key: "datasetName", label: "Dataset Name", align: "left" },
    { key: "harvestedDate", label: "Harvested Date", align: "left" },
    {
      key: "paymentsCount",
      label: "No. of Payments",
      align: "left",
      formatter: (item) => (
        <span
          style={{
            color: item.status === "PENDING" ? "#FFA500" : "inherit",
          }}
        >
          {item.status === "PENDING" ? (
            <ProgressSpinner data-testid="paymentSpinner" size="s" />
          ) : (
            item.paymentsCount
          )}
        </span>
      ),
    },
  ];

  render(
    <PaginatedTable
      loading={false}
      tableColumns={mockColumns}
      data={pendingMockData}
      pageNumber={1}
      sortColumns={[]}
      itemsPerPage={10}
      rowKey="activeRunId"
      onPagination={jest.fn()}
      highLightRow={true}
      highLightEntries={{
        key: "status",
        value: "PENDING",
      }}
    />
  );


  const paymentSpinner = screen.getByTestId('paymentSpinner');
  expect(paymentSpinner).toBeInTheDocument();


  const paymentText = screen.queryByText('5');
  expect(paymentText).not.toBeInTheDocument();


  const harvestedDateText = screen.queryByText("11-02-2024");
  expect(harvestedDateText).not.toBeInTheDocument();
});

 expect(paymentSpinners.length).toBeGreaterThan(0);
SHMX-2376 - Loaders for payment and date harvested tablecell and start and end date validation
