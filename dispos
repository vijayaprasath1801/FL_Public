export const renderXmlWithHighlights = (xmlDoc, side, differencesObj, indentLevel = 8) => {
  if (!xmlDoc) return null;

  const highlightColors = {
    1: '#a8e9c0', // Green disposition (0 1)
    2: '#f3a683', // Orange disposition (1 0)
    3: '#f78fb3', // Pink disposition (1 1)
  };

  const INDENT_TIMES = 6;
  const tag = xmlDoc.documentElement.tagName;
  const regExp = new RegExp(`(${tag}\\[(.+)\\]/)`, 'g');

  const getIndent = (level) => '\u00A0'.repeat(level * INDENT_TIMES);

  const walk = (node, level, isLeftSide) => {
    let children = [];
    let highlightColor = 'transparent';
    let emptyLinesCount = 0;

    // Handle ELEMENT_NODE logic
    if (node.nodeType === Node.ELEMENT_NODE) {
      children = Array.from(node.childNodes).map(child => walk(child, level + 1, isLeftSide));

      // Check differences for this node
      const xpathVal = getXPath(node); // Assuming getXPath is defined elsewhere
      for (const keyVal in differencesObj) {
        const disposition = differencesObj[keyVal]?.disposition || null;
        const nodeName = xpathVal.replace('/ns:RTPSMsg', '');

        if (differencesObj[keyVal]?.doesTheDifferenceExist && nodeName === node.nodeName) {
          if (disposition === 1 && isLeftSide) { // Present on right only
            highlightColor = highlightColors[1];
            emptyLinesCount++; // Increment empty lines for left side
          } else if (disposition === 2 && !isLeftSide) { // Present on left only
            highlightColor = highlightColors[2];
            emptyLinesCount++; // Increment empty lines for right side
          } else if (disposition === 3) { // Different between left and right
            highlightColor = highlightColors[3];
          }
        }
      }

      return (
        <div key={xpathVal} style={{ display: 'inline-block', backgroundColor: highlightColor }}>
          <span>{getIndent(level)}&lt;{node.nodeName}</span>
          {Array.from(node.attributes).map(attr => (
            <span key={attr.name}>{` ${attr.name}="${attr.value}"`}</span>
          ))}
          <span>&gt;</span>
          {children.length > 0 ? children : <hr />}
          <span>{getIndent(level)}</span>
          <span>{`</${node.nodeName}>`}</span>
        </div>
      );
    }

    // Handle TEXT_NODE logic
    else if (node.nodeType === Node.TEXT_NODE) {
      return <span>{node.nodeValue.replace(/\s/g, " ")}</span>;
    }

    return null;
  };

  // Render the XML with highlights
  const renderWithAlignment = () => {
    const leftRender = walk(xmlDoc.documentElement, indentLevel, true);
    const rightRender = walk(xmlDoc.documentElement, indentLevel, false);

    // Create empty lines based on counts from both sides
    const leftEmptyLines = Array.from({ length: emptyLinesCount }, (_, i) => (
      <div key={`empty-left-${i}`} style={{ height: '20px' }} />
    ));
    
    return (
      <div style={{ display: 'flex' }}>
        <div style={{ flex: 1 }}>
          {leftRender}
          {leftEmptyLines}
        </div>
        <div style={{ flex: 1 }}>
          {rightRender}
        </div>
      </div>
    );
  };

  return renderWithAlignment();
};
