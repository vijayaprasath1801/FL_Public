export const renderXmlWithHighlights = (xmlDoc, side, differencesObj, indentLevel = 8) => {
  if (!xmlDoc) return null;

  const highlightColors = {
    1: '#a8e9c0', // Green disposition 01 (right only)
    2: '#f3a683', // Orange disposition 10 (left only)
    3: '#f78fb3', // Pink disposition 11 (both different)
  };

  const INDENT_TIMES = 6;
  const regExp = new RegExp(`(${xmlDoc.documentElement.tagName}\\[(.+)\\]/)`, 'g');
  
  const getIndent = (level) => '\u00A0'.repeat(level * INDENT_TIMES);

  const createEmptyLines = (count, level) => (
    Array.from({ length: count }, (_, index) => (
      <div key={`empty-${index}`}>
        <span>{getIndent(level)}&nbsp;</span>
      </div>
    ))
  );

  const walk = (node, level) => {
    let isDiffExist = false;
    let highlightColor = 'transparent';
    let emptyLines = [];
    
    const xpathVal = getXPath(node);

    // Handle ELEMENT_NODE logic
    if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes).map(child => walk(child, level + 1));

      // Process difference highlighting and empty line creation
      for (const keyVal in differencesObj) {
        const disposition = differencesObj[keyVal]?.disposition || null;
        const expectedMessage = differencesObj[keyVal]?.expectedMessage || '';
        const actualMessage = differencesObj[keyVal]?.actualMessage || '';

        if (xpathVal.includes(keyVal) && differencesObj[keyVal]?.doesTheDifferenceExist) {
          switch (disposition) {
            case 1: // Right only (0,1)
              if (side === 'right') {
                isDiffExist = true;
                highlightColor = highlightColors[disposition];
              } else {
                emptyLines = createEmptyLines(actualMessage.split('\n').length, level);
              }
              break;

            case 2: // Left only (1,0)
              if (side === 'left') {
                isDiffExist = true;
                highlightColor = highlightColors[disposition];
              } else {
                emptyLines = createEmptyLines(expectedMessage.split('\n').length, level);
              }
              break;

            case 3: // Both sides different (1,1)
              isDiffExist = true;
              highlightColor = highlightColors[disposition];
              break;

            default:
              break;
          }
        }
      }

      const shouldHighlight = isDiffExist;

      // Render the element
      return (
        <>
          <div
            className="tempDiv"
            style={{ display: 'inline-block', backgroundColor: shouldHighlight ? highlightColor : 'transparent' }}
          >
            <span>{getIndent(level)}&lt;{node.nodeName}</span>
            {Array.from(node.attributes).map(attr => (
              <span key={attr.name}>{` ${attr.name}="${attr.value}"`}</span>
            ))}
            <span>&gt;</span>
          </div>
          {children.length > 0 ? children : <hr />}
          {emptyLines}
          <div>
            <span>{getIndent(level)}</span>
            <span>{`</${node.nodeName}>`}</span>
          </div>
        </>
      );
    }

    // Handle TEXT_NODE logic
    else if (node.nodeType === Node.TEXT_NODE) {
      return (
        <div>
          <span style={{ backgroundColor: isDiffExist ? highlightColor : 'transparent' }}>
            {node.nodeValue.replace(/\s/g, " ")}
          </span>
        </div>
      );
    }

    return null;
  };

  return walk(xmlDoc.documentElement, indentLevel);
};
