export const renderXmlWithHighlights = (xmlDoc, side, differencesObj, indentLevel = 8) => {
  if (!xmlDoc) return null;

  const highlightColors = {
    1: '#a8e9c0', // Green disposition 01
    2: '#f3a683', // Orange disposition 10
    3: '#f78fb3', // Pink disposition 11
  };

  const INDENT_TIMES = 6;

  const getIndent = (level) => '\u00A0'.repeat(level * INDENT_TIMES);

  const walk = (node, level, isLeftSide) => {
    let isDiffExist = false;
    let highlightColor = 'transparent';
    const xpathVal = getXPath(node);

    if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes).map((child) =>
        walk(child, level + 1, isLeftSide)
      );

      for (const keyVal in differencesObj) {
        const diffDisposition = differencesObj[keyVal]?.disposition;
        const doesDifferenceExist = differencesObj[keyVal]?.doesTheDifferenceExist;
        const nodeContent =
          node.childNodes[0]?.textContent.replace(/\s/g, "") || "";
        const expectedContent =
          differencesObj[keyVal]?.expectedMessage.replace(/\s/g, "") || "";

        if (doesDifferenceExist) {
          if (diffDisposition === 1 && side === "right" && nodeContent === expectedContent) {
            isDiffExist = true;
            highlightColor = highlightColors[1];
          } else if (diffDisposition === 2 && side === "left" && nodeContent === expectedContent) {
            isDiffExist = true;
            highlightColor = highlightColors[2];
          } else if (diffDisposition === 3 && nodeContent !== expectedContent) {
            isDiffExist = true;
            highlightColor = highlightColors[3];
          }
        }
      }

      const shouldHighlight = isDiffExist;

      return (
        <div
          className="tempDiv"
          style={{
            display: "inline-block",
            backgroundColor: shouldHighlight ? highlightColor : "transparent",
          }}
        >
          <span>
            {getIndent(level)}&lt;{node.nodeName}
          </span>
          {Array.from(node.attributes).map((attr) => (
            <span key={attr.name}>{` ${attr.name}="${attr.value}"`}</span>
          ))}
          <span>&gt;</span>
          {children.length > 0 ? children : <hr />}
          <span>{getIndent(level)}</span>
          <span>{`</${node.nodeName}>`}</span>
        </div>
      );
    } else if (node.nodeType === Node.TEXT_NODE) {
      return <span>{node.nodeValue.replace(/\s/g, " ")}</span>;
    }

    return null;
  };

  const renderAlignedXml = (isLeftSide) => {
    const content = walk(xmlDoc.documentElement, indentLevel, isLeftSide);

    if (side === "right" && differencesObj[1]) {
      const alignmentPadding = "\u00A0".repeat(
        differencesObj[1].expectedMessage.length * INDENT_TIMES
      );
      return (
        <>
          {alignmentPadding}
          {content}
        </>
      );
    } else if (side === "left" && differencesObj[2]) {
      const alignmentPadding = "\u00A0".repeat(
        differencesObj[2].expectedMessage.length * INDENT_TIMES
      );
      return (
        <>
          {alignmentPadding}
          {content}
        </>
      );
    }

    return content;
  };

  return renderAlignedXml(side === "left");
};
