export const renderXmlWithHighlights = (
  leftXmlDoc,
  rightXmlDoc,
  differencesObj,
  indentLevel = 8,
) => {
  if (!leftXmlDoc || !rightXmlDoc) return null

  const highlightColors = {
    1: '#a8e9c0', // Green disposition 01 (Present on the right only)
    2: '#f3a683', // Orange disposition 10 (Present on the left only)
    3: '#f78fb3', // Pink disposition 11 (Different between left and right)
  }

  const INDENT_TIMES = 6
  const getIndent = (level) => '\u00A0'.repeat(level * INDENT_TIMES)

  const regExp = new RegExp(
    `(${leftXmlDoc.documentElement.tagName}\\[(.+)\\]/)`,
    'g',
  )

  const getXPath = (node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      let path = node.nodeName
      while (node.parentNode) {
        node = node.parentNode
        path = node.nodeName + '/' + path
      }
      return path
    }
    return ''
  }


  const getElementLineCount = (node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      let lineCount = 1 // The element itself counts as 1 line
      Array.from(node.childNodes).forEach((child) => {
        lineCount += getElementLineCount(child)
      })
      return lineCount
    }
    return 0
  }

  const walk = (node, level, xmlDoc, isRightSide) => {
    let isDiffExist = false
    let highlightColor = 'transparent'
    const xpathVal = getXPath(node)

    if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes).map((child) =>
        walk(child, level + 1, xmlDoc, isRightSide),
      )


      for (const keyVal in differencesObj) {
        const nodeName = xpathVal.replace('/ns:RTPSMsg', '')
        const diffNodePath = keyVal.replace(regExp, '')
        const disposition = differencesObj[keyVal]?.disposition || null
        const doesDiffExist = differencesObj[keyVal]?.doesTheDifferenceExist

        if (doesDiffExist && nodeName === node.nodeName) {
          if (isRightSide && disposition === 1) {
            // Disposition 1 (Right only)
            isDiffExist = true
            highlightColor = highlightColors[1]
          } else if (!isRightSide && disposition === 2) {
            // Disposition 2 (Left only)
            isDiffExist = true
            highlightColor = highlightColors[2]
          } else if (disposition === 3) {
            // Disposition 3 (Different in both)
            isDiffExist = true
            highlightColor = highlightColors[3]
          }
        }
      }

      const shouldHighlight = isDiffExist

   
      return (
        <div
          className="tempDiv"
          style={{
            display: 'inline-block',
            backgroundColor: shouldHighlight ? highlightColor : 'transparent',
          }}
        >
          <span>
            {getIndent(level)}&lt;{node.nodeName}
          </span>
          {Array.from(node.attributes).map((attr) => (
            <span key={attr.name}>{` ${attr.name}="${attr.value}"`}</span>
          ))}
          <span>&gt;</span>
          {children.length > 0 ? children : <hr />}
          <span>{getIndent(level)}</span>
          <span>{`</${node.nodeName}>`}</span>
        </div>
      )
    }


    else if (node.nodeType === Node.TEXT_NODE) {
      return <span>{node.nodeValue.replace(/\s/g, ' ')}</span>
    }

    return null
  }

  const renderSideXml = (xmlDoc, isRightSide) => {
    let emptyLineCount = 0
    const renderXmlContent = walk(
      xmlDoc.documentElement,
      indentLevel,
      xmlDoc,
      isRightSide,
    )

    if (isRightSide) {
      Array.from(xmlDoc.documentElement.childNodes).forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const lineCount = getElementLineCount(node)
          emptyLineCount += lineCount
        }
      })
    }

    // Return the content with the calculated empty lines in the left side if necessary
    return renderXmlContent
  }

  return (
    <div style={{display: 'flex'}}>
      <div style={{flex: 1}}>{renderSideXml(leftXmlDoc, false)}</div>
      <div style={{flex: 1}}>{renderSideXml(rightXmlDoc, true)}</div>
    </div>
  )
}
