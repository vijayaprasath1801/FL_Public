export const renderXmlWithHighlights = (xmlDoc, side, differencesObj, indentLevel = 8) => {
  if (!xmlDoc) return null;

  const highlightColors = {
    1: '#a8e9c0', // Green disposition 01 (Present on right only)
    2: '#f3a683', // Orange disposition 10 (Present on left only)
    3: '#f78fb3', // Pink disposition 11 (Different between left and right)
  };

  const INDENT_TIMES = 6;
  const tag = xmlDoc.documentElement.tagName;
  const regExp = new RegExp(`(${tag}\\[(.+)\\]/)`, 'g');

  const getIndent = (level) => '\u00A0'.repeat(level * INDENT_TIMES);

  const walk = (node, level, isRightDoc) => {
    let isDiffExist = false;
    let highlightColor = 'transparent';
    const xpathVal = getXPath(node);

    // Handle ELEMENT_NODE logic
    if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes).map(child => walk(child, level + 1, isRightDoc));

      // Determine highlighting logic
      for (const keyVal in differencesObj) {
        const key = keyVal.replace(regExp, '');
        const nodeName = xpathVal.replace('/ns:RTPSMsg', '');
        const diffNodePath = keyVal.replace(regExp, '');
        const disposition = differencesObj[keyVal]?.disposition || null;

        if (
          differencesObj[keyVal]?.doesTheDifferenceExist &&
          nodeName === node.nodeName &&
          node.childNodes[0]?.textContent.replace(/\s/g, '') ===
            differencesObj[keyVal]?.expectedMessage.replace(/\s/g, '')
        ) {
          isDiffExist = true;
          highlightColor = highlightColors[disposition] || 'transparent';
        }
      }

      const shouldHighlight = isDiffExist;

      // If disposition is 2 (orange), render an empty node for alignment in the left document
      if (isRightDoc && !shouldHighlight) {
        // Placeholder for missing node (Disposition 2)
        return (
          <div
            className="tempDiv"
            style={{ display: 'inline-block', backgroundColor: 'transparent' }}
          >
            <span>{getIndent(level)}&lt;{node.nodeName}&gt;</span>
            {children.length > 0 ? children : <hr />}
            <span>{getIndent(level)}</span>
            <span>{`</${node.nodeName}>`}</span>
          </div>
        );
      }

      // Render the element with or without highlights
      return (
        <div
          className="tempDiv"
          style={{ display: 'inline-block', backgroundColor: shouldHighlight ? highlightColor : 'transparent' }}
        >
          <span>{getIndent(level)}&lt;{node.nodeName}</span>
          {Array.from(node.attributes).map(attr => (
            <span key={attr.name}>{` ${attr.name}="${attr.value}"`}</span>
          ))}
          <span>&gt;</span>
          {children.length > 0 ? children : <hr />}
          <span>{getIndent(level)}</span>
          <span>{`</${node.nodeName}>`}</span>
        </div>
      );
    }

    // Handle TEXT_NODE logic
    else if (node.nodeType === Node.TEXT_NODE) {
      return <span>{node.nodeValue.replace(/\s/g, ' ')}</span>;
    }

    return null;
  };

  // Walk through the XML and render with alignment for both sides
  const renderForSide = (isRightDoc) => {
    return walk(xmlDoc.documentElement, indentLevel, isRightDoc);
  };

  return (
    <div>
      {/* Render the left XML (empty nodes for missing right-side elements) */}
      {renderForSide(false)}

      {/* Render the right XML with alignment and differences highlighted */}
      {renderForSide(true)}
    </div>
  );
};

function getXPath(node) {
  if (node === document) return "/";

  let path = "";
  while (node && node.nodeType === Node.ELEMENT_NODE) {
    let index = 1;
    let sibling = node.previousSibling;
    while (sibling) {
      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === node.nodeName) {
        index++;
      }
      sibling = sibling.previousSibling;
    }
    const tagName = node.nodeName;
    path = `/${tagName}[${index}]${path}`;
    node = node.parentNode;
  }
  return path;
}
